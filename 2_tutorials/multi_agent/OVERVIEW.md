# Multi-agent System
- **정의**: 단일 에이전트가 아닌 여러 에이전트가 협력하여 복잡한 문제를 해결하는 시스템입니다.
- **문제 해결**: 단일 에이전트가 과도한 도구(Tool)나 방대한 컨텍스트로 인해 의사결정 품질이 저하되는 문제를 해결하기 위해 멀티 에이전트 아키텍처를 제안합니다.
- **최종 목표**: 요구사항(지연 시간, 비용, 복잡성)에 따라 적절한 멀티 에이전트 패턴(Subagents, Handoffs, Skills, Router 등)을 선택하고 구현할 수 있습니다.

<br>

## 2️⃣ 전체 구조 맵 (What)
- **Multi-agent System**
  - **Core Drivers (필요성)**
    - Context Management (컨텍스트 관리)
    - Distributed Development (분산 개발)
    - Parallelization (병렬화)
  - **Patterns (구현 패턴)**
    - **Subagents**: 메인 에이전트가 서브 에이전트를 도구처럼 관리 (중앙 집중식)
    - **Handoffs**: 상태 변화에 따라 에이전트 간 제어권 양도 (동적 전환)
    - **Skills**: 온디맨드로 프롬프트와 지식을 로드 (단일 에이전트 유지)
    - **Router**: 입력을 분류하여 전담 에이전트로 전달 (분류기 기반)
    - **Custom Workflow**: LangGraph를 이용한 커스텀 흐름 설계
  - **Performance Metrics (평가 지표)**
    - Model Calls (모델 호출 횟수)
    - Tokens Processed (토큰 처리량)

<br>

## 3️⃣ 핵심 개념 설명 (How)

### Subagents (서브 에이전트)
- **정의**: 메인 에이전트가 서브 에이전트들을 하위 도구로 사용하여 모든 통신을 중앙에서 통제하는 구조입니다.
- **특징**: 강력한 중앙 제어 가능, 서브 에이전트 간 컨텍스트가 격리되어 정확도 높음.
- **오해**: 호출 횟수가 가장 적을 것 같지만, 모든 결과가 메인을 거치므로 다른 패턴보다 호출 횟수가 많아질 수 있습니다.

### Handoffs (핸드오프)
- **정의**: 에이전트가 특정 조건 충족 시 다른 에이전트에게 직접 제어권을 넘겨주는 상태 기반 전환 방식입니다.
- **특징**: 에이전트 간 직접 대화 가능, 대화형 서비스(유저 상호작용)에 최적화.
- **오해**: 모든 작업을 병렬로 처리할 수 있을 것 같지만, 제어권이 순차적으로 넘어가므로 병렬 처리에는 적합하지 않습니다.

### Context Engineering (컨텍스트 엔지니어링)
- **정의**: 각 에이전트가 작업을 수행하는 데 필요한 최적의 정보만을 선별해서 제공하는 설계 기법입니다.
- **특징**: 멀티 에이전트 설계의 핵심, 무한한 컨텍스트가 불가능한 현실적인 대안.
- **오해**: 단순한 프롬프트 작성이 아니라, 에이전트가 '무엇을 볼 것인가'를 결정하는 아키텍처적 결정입니다.

<br>

## 4️⃣ 선택지 / 옵션 / 패턴 정리 (Compare)

| 패턴 | 목적 | 장점 | 단점 | 사용 시점 |
| :--- | :--- | :--- | :--- | :--- |
| **Subagents** | 중앙 집중형 제어 | 분산 개발 용이, 병렬화 최상 | 모델 호출 횟수 많음 (오버헤드) | 복잡한 도메인이 섞인 병렬 작업 |
| **Handoffs** | 동적 역할 전환 | 유저 상호작용 최상, 호출 효율적 | 병렬 처리 불가 (순차적) | 고객 상담 등 단계별 흐름이 명확할 때 |
| **Skills** | 지식 로드 (단일 에이전트) | 제어권 유지, 반복 요청 시 효율 | 토큰 누적으로 비용 증가 위험 | 단일 에이전트가 특수 지식만 필요할 때 |
| **Router** | 입력 기반 자동 분류 | 초기 지연 시간 낮음, 병렬화 가능 | 상태 유지가 어려움 (Stateless) | 명확히 구분된 전문 영역이 여러 개일 때 |

<br>

## 5️⃣ 판단 기준 요약 (Decision Guide)
- **성능(지연 시간) 우선**:
  - 반복되는 요청이 많다면 **Handoffs**나 **Skills**를 선택하세요. (추가 호출 감소)
  - 한 번에 여러 일을 끝내야 한다면 **Subagents**나 **Router**를 통해 병렬 실행하세요.
- **비용/효율성 우선**:
  - 도메인 지식이 방대하다면 **Subagents**를 쓰세요. (컨텍스트 격리로 토큰 절약)
  - 지식이 단순하고 짧다면 **Skills**가 모델 호출을 줄여 더 경제적입니다.
- **확장성/유지보수 우선**:
  - 여러 팀이 각자 기능을 개발해야 한다면 **Subagents**나 **Skills**를 통해 독립성을 확보하세요.

<br>

## 6️⃣ 실무 관점 요약
- **실무 적용**: "에이전트가 너무 많은 도구를 가져서 멍청해질 때"가 멀티 에이전트 도입의 신호입니다. 처음에는 단일 에이전트로 시작하고, 성능 저하 시 위 패턴 중 하나로 분리하십시오.
- **바로 적용 포인트**: 반복 문답이 많은 챗봇에는 **Handoffs**를, 기술 문서 검색기에는 컨텍스트 격리가 좋은 **Subagents**를 우선 고려하세요.
- **당장 안 써도 되는 경우**: 단일 에이전트의 프롬프트 수정이나 동적 도구 선택(Dynamic Tool selection)만으로도 문제가 해결된다면 굳이 아키텍처를 복잡하게 만들지 마세요.

<br>

## 7️⃣ 한 문장 요약
멀티 에이전트 시스템은 무한한 컨텍스트의 한계를 극복하기 위해 제어권 분산(Handoffs/Router)과 컨텍스트 격리(Subagents)를 전략적으로 선택하는 기술입니다.
- **문제 해결**: 단일 에이전트가 과도한 도구(Tool)나 방대한 컨텍스트로 인해 의사결정 품질이 저하되는 문제를 해결하기 위해 멀티 에이전트 아키텍처를 제안합니다.
- **최종 목표**: 요구사항(지연 시간, 비용, 복잡성)에 따라 적절한 멀티 에이전트 패턴(Subagents, Handoffs, Skills, Router 등)을 선택하고 구현할 수 있습니다.

<br>

## 전체 구조 맵 (What)
- **Multi-agent System**
  - **Core Drivers (필요성)**
    - Context Management (컨텍스트 관리)
    - Distributed Development (분산 개발)
    - Parallelization (병렬화)
  - **Patterns (구현 패턴)**
    - **Subagents**: 메인 에이전트가 서브 에이전트를 도구처럼 관리 (중앙 집중식)
    - **Handoffs**: 상태 변화에 따라 에이전트 간 제어권 양도 (동적 전환)
    - **Skills**: 온디맨드로 프롬프트와 지식을 로드 (단일 에이전트 유지)
    - **Router**: 입력을 분류하여 전담 에이전트로 전달 (분류기 기반)
    - **Custom Workflow**: LangGraph를 이용한 커스텀 흐름 설계
  - **Performance Metrics (평가 지표)**
    - Model Calls (모델 호출 횟수)
    - Tokens Processed (토큰 처리량)

<br>

## 핵심 개념 설명 (How)

### Subagents (서브 에이전트)
- **정의**: 메인 에이전트가 서브 에이전트들을 하위 도구로 사용하여 모든 통신을 중앙에서 통제하는 구조입니다.
- **특징**: 강력한 중앙 제어 가능, 서브 에이전트 간 컨텍스트가 격리되어 정확도 높음.
- **오해**: 호출 횟수가 가장 적을 것 같지만, 모든 결과가 메인을 거치므로 다른 패턴보다 호출 횟수가 많아질 수 있습니다.

### Handoffs (핸드오프)
- **정의**: 에이전트가 특정 조건 충족 시 다른 에이전트에게 직접 제어권을 넘겨주는 상태 기반 전환 방식입니다.
- **특징**: 에이전트 간 직접 대화 가능, 대화형 서비스(유저 상호작용)에 최적화.
- **오해**: 모든 작업을 병렬로 처리할 수 있을 것 같지만, 제어권이 순차적으로 넘어가므로 병렬 처리에는 적합하지 않습니다.

### Context Engineering (컨텍스트 엔지니어링)
- **정의**: 각 에이전트가 작업을 수행하는 데 필요한 최적의 정보만을 선별해서 제공하는 설계 기법입니다.
- **특징**: 멀티 에이전트 설계의 핵심, 무한한 컨텍스트가 불가능한 현실적인 대안.
- **오해**: 단순한 프롬프트 작성이 아니라, 에이전트가 '무엇을 볼 것인가'를 결정하는 아키텍처적 결정입니다.

<br>

## 선택지 / 옵션 / 패턴 정리 (Compare)

| 패턴 | 목적 | 장점 | 단점 | 사용 시점 |
| :--- | :--- | :--- | :--- | :--- |
| **Subagents** | 중앙 집중형 제어 | 분산 개발 용이, 병렬화 최상 | 모델 호출 횟수 많음 (오버헤드) | 복잡한 도메인이 섞인 병렬 작업 |
| **Handoffs** | 동적 역할 전환 | 유저 상호작용 최상, 호출 효율적 | 병렬 처리 불가 (순차적) | 고객 상담 등 단계별 흐름이 명확할 때 |
| **Skills** | 지식 로드 (단일 에이전트) | 제어권 유지, 반복 요청 시 효율 | 토큰 누적으로 비용 증가 위험 | 단일 에이전트가 특수 지식만 필요할 때 |
| **Router** | 입력 기반 자동 분류 | 초기 지연 시간 낮음, 병렬화 가능 | 상태 유지가 어려움 (Stateless) | 명확히 구분된 전문 영역이 여러 개일 때 |

<br>

## 판단 기준 요약 (Decision Guide)
- **성능(지연 시간) 우선**:
  - 반복되는 요청이 많다면 **Handoffs**나 **Skills**를 선택하세요. (추가 호출 감소)
  - 한 번에 여러 일을 끝내야 한다면 **Subagents**나 **Router**를 통해 병렬 실행하세요.
- **비용/효율성 우선**:
  - 도메인 지식이 방대하다면 **Subagents**를 쓰세요. (컨텍스트 격리로 토큰 절약)
  - 지식이 단순하고 짧다면 **Skills**가 모델 호출을 줄여 더 경제적입니다.
- **확장성/유지보수 우선**:
  - 여러 팀이 각자 기능을 개발해야 한다면 **Subagents**나 **Skills**를 통해 독립성을 확보하세요.

<br>

## 실무 관점 요약
- **실무 적용**: "에이전트가 너무 많은 도구를 가져서 멍청해질 때"가 멀티 에이전트 도입의 신호입니다. 처음에는 단일 에이전트로 시작하고, 성능 저하 시 위 패턴 중 하나로 분리하십시오.
- **바로 적용 포인트**: 반복 문답이 많은 챗봇에는 **Handoffs**를, 기술 문서 검색기에는 컨텍스트 격리가 좋은 **Subagents**를 우선 고려하세요.
- **당장 안 써도 되는 경우**: 단일 에이전트의 프롬프트 수정이나 동적 도구 선택(Dynamic Tool selection)만으로도 문제가 해결된다면 굳이 아키텍처를 복잡하게 만들지 마세요.

<br>

## 한 문장 요약
멀티 에이전트 시스템은 무한한 컨텍스트의 한계를 극복하기 위해 제어권 분산(Handoffs/Router)과 컨텍스트 격리(Subagents)를 전략적으로 선택하는 기술입니다.